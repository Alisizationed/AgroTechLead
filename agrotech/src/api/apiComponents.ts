/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, type ApiContext, queryKeyFn } from "./apiContext";
import { deepMerge } from "./apiUtils";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type GetCadastresError = Fetcher.ErrorWrapper<undefined>;

export type GetCadastresResponse = Schemas.Cadastru[];

export type GetCadastresVariables = ApiContext["fetcherOptions"];

export const fetchGetCadastres = (
  variables: GetCadastresVariables,
  signal?: AbortSignal,
) =>
  apiFetch<GetCadastresResponse, GetCadastresError, undefined, {}, {}, {}>({
    url: "/cadastru",
    method: "get",
    ...variables,
    signal,
  });

export function getCadastresQuery(variables: GetCadastresVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCadastresResponse>;
};

export function getCadastresQuery(
  variables: GetCadastresVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCadastresResponse>)
    | reactQuery.SkipToken;
};

export function getCadastresQuery(
  variables: GetCadastresVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cadastru",
      operationId: "getCadastres",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCadastres(variables, signal),
  };
}

export const useSuspenseGetCadastres = <TData = GetCadastresResponse,>(
  variables: GetCadastresVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCadastresResponse, GetCadastresError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetCadastresResponse,
    GetCadastresError,
    TData
  >({
    ...getCadastresQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCadastres = <TData = GetCadastresResponse,>(
  variables: GetCadastresVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCadastresResponse, GetCadastresError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetCadastresResponse, GetCadastresError, TData>({
    ...getCadastresQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SaveCadastruError = Fetcher.ErrorWrapper<undefined>;

export type SaveCadastruVariables = {
  body?: Schemas.Cadastru;
} & ApiContext["fetcherOptions"];

export const fetchSaveCadastru = (
  variables: SaveCadastruVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Schemas.Cadastru, SaveCadastruError, Schemas.Cadastru, {}, {}, {}>({
    url: "/cadastru",
    method: "post",
    ...variables,
    signal,
  });

export const useSaveCadastru = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Cadastru,
      SaveCadastruError,
      SaveCadastruVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.Cadastru,
    SaveCadastruError,
    SaveCadastruVariables
  >({
    mutationFn: (variables: SaveCadastruVariables) =>
      fetchSaveCadastru(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCadastruPathParams = {
  id: string;
};

export type GetCadastruError = Fetcher.ErrorWrapper<undefined>;

export type GetCadastruResponse = Schemas.Cadastru[];

export type GetCadastruVariables = {
  pathParams: GetCadastruPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetCadastru = (
  variables: GetCadastruVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetCadastruResponse,
    GetCadastruError,
    undefined,
    {},
    {},
    GetCadastruPathParams
  >({ url: "/user/{id}", method: "get", ...variables, signal });

export function getCadastruQuery(variables: GetCadastruVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCadastruResponse>;
};

export function getCadastruQuery(
  variables: GetCadastruVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCadastruResponse>)
    | reactQuery.SkipToken;
};

export function getCadastruQuery(
  variables: GetCadastruVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/user/{id}",
      operationId: "getCadastru",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCadastru(variables, signal),
  };
}

export const useSuspenseGetCadastru = <TData = GetCadastruResponse,>(
  variables: GetCadastruVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCadastruResponse, GetCadastruError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetCadastruResponse,
    GetCadastruError,
    TData
  >({
    ...getCadastruQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCadastru = <TData = GetCadastruResponse,>(
  variables: GetCadastruVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCadastruResponse, GetCadastruError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetCadastruResponse, GetCadastruError, TData>({
    ...getCadastruQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetRaionPathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetRaionError = Fetcher.ErrorWrapper<undefined>;

export type GetRaionVariables = {
  pathParams: GetRaionPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetRaion = (
  variables: GetRaionVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Schemas.Raion, GetRaionError, undefined, {}, {}, GetRaionPathParams>(
    { url: "/raion/{id}", method: "get", ...variables, signal },
  );

export function getRaionQuery(variables: GetRaionVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Raion>;
};

export function getRaionQuery(
  variables: GetRaionVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Raion>)
    | reactQuery.SkipToken;
};

export function getRaionQuery(
  variables: GetRaionVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raion/{id}",
      operationId: "getRaion",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRaion(variables, signal),
  };
}

export const useSuspenseGetRaion = <TData = Schemas.Raion,>(
  variables: GetRaionVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Raion, GetRaionError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Raion, GetRaionError, TData>({
    ...getRaionQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetRaion = <TData = Schemas.Raion,>(
  variables: GetRaionVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Raion, GetRaionError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.Raion, GetRaionError, TData>({
    ...getRaionQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCadastru1PathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetCadastru1Error = Fetcher.ErrorWrapper<undefined>;

export type GetCadastru1Variables = {
  pathParams: GetCadastru1PathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetCadastru1 = (
  variables: GetCadastru1Variables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.Cadastru,
    GetCadastru1Error,
    undefined,
    {},
    {},
    GetCadastru1PathParams
  >({ url: "/cadastru/{id}", method: "get", ...variables, signal });

export function getCadastru1Query(variables: GetCadastru1Variables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Cadastru>;
};

export function getCadastru1Query(
  variables: GetCadastru1Variables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Cadastru>)
    | reactQuery.SkipToken;
};

export function getCadastru1Query(
  variables: GetCadastru1Variables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cadastru/{id}",
      operationId: "getCadastru1",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCadastru1(variables, signal),
  };
}

export const useSuspenseGetCadastru1 = <TData = Schemas.Cadastru,>(
  variables: GetCadastru1Variables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Cadastru, GetCadastru1Error, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.Cadastru,
    GetCadastru1Error,
    TData
  >({
    ...getCadastru1Query(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCadastru1 = <TData = Schemas.Cadastru,>(
  variables: GetCadastru1Variables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Cadastru, GetCadastru1Error, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.Cadastru, GetCadastru1Error, TData>({
    ...getCadastru1Query(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetLivestockPathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetLivestockError = Fetcher.ErrorWrapper<undefined>;

export type GetLivestockResponse = Schemas.LivestockDTO[];

export type GetLivestockVariables = {
  pathParams: GetLivestockPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetLivestock = (
  variables: GetLivestockVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetLivestockResponse,
    GetLivestockError,
    undefined,
    {},
    {},
    GetLivestockPathParams
  >({ url: "/cadastru/{id}/livestock", method: "get", ...variables, signal });

export function getLivestockQuery(variables: GetLivestockVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetLivestockResponse>;
};

export function getLivestockQuery(
  variables: GetLivestockVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetLivestockResponse>)
    | reactQuery.SkipToken;
};

export function getLivestockQuery(
  variables: GetLivestockVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cadastru/{id}/livestock",
      operationId: "getLivestock",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetLivestock(variables, signal),
  };
}

export const useSuspenseGetLivestock = <TData = GetLivestockResponse,>(
  variables: GetLivestockVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetLivestockResponse, GetLivestockError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetLivestockResponse,
    GetLivestockError,
    TData
  >({
    ...getLivestockQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetLivestock = <TData = GetLivestockResponse,>(
  variables: GetLivestockVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetLivestockResponse, GetLivestockError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetLivestockResponse, GetLivestockError, TData>({
    ...getLivestockQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCropsPathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetCropsError = Fetcher.ErrorWrapper<undefined>;

export type GetCropsResponse = Schemas.CropDTO[];

export type GetCropsVariables = {
  pathParams: GetCropsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetCrops = (
  variables: GetCropsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetCropsResponse,
    GetCropsError,
    undefined,
    {},
    {},
    GetCropsPathParams
  >({ url: "/cadastru/{id}/crops", method: "get", ...variables, signal });

export function getCropsQuery(variables: GetCropsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCropsResponse>;
};

export function getCropsQuery(
  variables: GetCropsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCropsResponse>)
    | reactQuery.SkipToken;
};

export function getCropsQuery(
  variables: GetCropsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cadastru/{id}/crops",
      operationId: "getCrops",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCrops(variables, signal),
  };
}

export const useSuspenseGetCrops = <TData = GetCropsResponse,>(
  variables: GetCropsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCropsResponse, GetCropsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<GetCropsResponse, GetCropsError, TData>({
    ...getCropsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCrops = <TData = GetCropsResponse,>(
  variables: GetCropsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCropsResponse, GetCropsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetCropsResponse, GetCropsError, TData>({
    ...getCropsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCadastruByLivestockQueryParams = {
  livestock: string;
};

export type GetCadastruByLivestockError = Fetcher.ErrorWrapper<undefined>;

export type GetCadastruByLivestockResponse = Schemas.CadastruLivestockDTO[];

export type GetCadastruByLivestockVariables = {
  queryParams: GetCadastruByLivestockQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetCadastruByLivestock = (
  variables: GetCadastruByLivestockVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetCadastruByLivestockResponse,
    GetCadastruByLivestockError,
    undefined,
    {},
    GetCadastruByLivestockQueryParams,
    {}
  >({ url: "/cadastru/livestock", method: "get", ...variables, signal });

export function getCadastruByLivestockQuery(
  variables: GetCadastruByLivestockVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCadastruByLivestockResponse>;
};

export function getCadastruByLivestockQuery(
  variables: GetCadastruByLivestockVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCadastruByLivestockResponse>)
    | reactQuery.SkipToken;
};

export function getCadastruByLivestockQuery(
  variables: GetCadastruByLivestockVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cadastru/livestock",
      operationId: "getCadastruByLivestock",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCadastruByLivestock(variables, signal),
  };
}

export const useSuspenseGetCadastruByLivestock = <
  TData = GetCadastruByLivestockResponse,
>(
  variables: GetCadastruByLivestockVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCadastruByLivestockResponse,
      GetCadastruByLivestockError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetCadastruByLivestockResponse,
    GetCadastruByLivestockError,
    TData
  >({
    ...getCadastruByLivestockQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCadastruByLivestock = <
  TData = GetCadastruByLivestockResponse,
>(
  variables: GetCadastruByLivestockVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCadastruByLivestockResponse,
      GetCadastruByLivestockError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetCadastruByLivestockResponse,
    GetCadastruByLivestockError,
    TData
  >({
    ...getCadastruByLivestockQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCadastruByCropQueryParams = {
  crop: string;
};

export type GetCadastruByCropError = Fetcher.ErrorWrapper<undefined>;

export type GetCadastruByCropResponse = Schemas.CadastruCropDTO[];

export type GetCadastruByCropVariables = {
  queryParams: GetCadastruByCropQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetCadastruByCrop = (
  variables: GetCadastruByCropVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetCadastruByCropResponse,
    GetCadastruByCropError,
    undefined,
    {},
    GetCadastruByCropQueryParams,
    {}
  >({ url: "/cadastru/crop", method: "get", ...variables, signal });

export function getCadastruByCropQuery(variables: GetCadastruByCropVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCadastruByCropResponse>;
};

export function getCadastruByCropQuery(
  variables: GetCadastruByCropVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCadastruByCropResponse>)
    | reactQuery.SkipToken;
};

export function getCadastruByCropQuery(
  variables: GetCadastruByCropVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cadastru/crop",
      operationId: "getCadastruByCrop",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCadastruByCrop(variables, signal),
  };
}

export const useSuspenseGetCadastruByCrop = <
  TData = GetCadastruByCropResponse,
>(
  variables: GetCadastruByCropVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCadastruByCropResponse,
      GetCadastruByCropError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetCadastruByCropResponse,
    GetCadastruByCropError,
    TData
  >({
    ...getCadastruByCropQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCadastruByCrop = <TData = GetCadastruByCropResponse,>(
  variables: GetCadastruByCropVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCadastruByCropResponse,
      GetCadastruByCropError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetCadastruByCropResponse,
    GetCadastruByCropError,
    TData
  >({
    ...getCadastruByCropQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/cadastru";
      operationId: "getCadastres";
      variables: GetCadastresVariables | reactQuery.SkipToken;
    }
  | {
      path: "/user/{id}";
      operationId: "getCadastru";
      variables: GetCadastruVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raion/{id}";
      operationId: "getRaion";
      variables: GetRaionVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cadastru/{id}";
      operationId: "getCadastru1";
      variables: GetCadastru1Variables | reactQuery.SkipToken;
    }
  | {
      path: "/cadastru/{id}/livestock";
      operationId: "getLivestock";
      variables: GetLivestockVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cadastru/{id}/crops";
      operationId: "getCrops";
      variables: GetCropsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cadastru/livestock";
      operationId: "getCadastruByLivestock";
      variables: GetCadastruByLivestockVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cadastru/crop";
      operationId: "getCadastruByCrop";
      variables: GetCadastruByCropVariables | reactQuery.SkipToken;
    };
